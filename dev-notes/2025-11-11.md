# 2025-11-11 Dev Notes

## Version 2.0.0 - Major API Improvements

Today we implemented significant breaking changes to improve the API clarity, consistency, and developer experience based on user feedback and design discussions.

---

## Changes Made

### 1. Fixed IDE Import Experience

**Problem**: When typing "gluify" in IDE autocomplete, it showed `@node_modules/gluify/dist/Gluify` instead of clean `gluify` import.

**Root Cause**: `package.json` had `"main": "dist/Gluify.js"` with the `dist/` prefix, causing IDEs to include the directory in import suggestions.

**Solution**: Following industry standard pattern from axios, express, and jsforce:
- Created hand-written `index.js` at package root (re-exports from `./dist/Gluify`)
- Created hand-written `index.d.ts` at package root (type definitions)
- Updated `package.json`:
  - `"main": "dist/Gluify.js"` ‚Üí `"main": "index.js"`
  - `"types": "dist/Gluify.d.ts"` ‚Üí `"types": "index.d.ts"`
  - Added `exports` field for modern module resolution
  - Added index files to `files` array
- Updated `tsconfig.json` to only compile source files, not index

**Files Changed**:
- Created: `index.js`, `index.d.ts`
- Modified: `package.json`, `tsconfig.json`

**Result**:
```typescript
// Now users get clean imports:
import { gluify } from "gluify";  // ‚úÖ
// Instead of:
import { gluify } from "@node_modules/gluify/dist/Gluify";  // ‚ùå
```

---

### 2. Renamed `.value()` / `.valueAsync()` ‚Üí `.run()` / `.runAsync()`

**Problem**: `.value()` and `.valueAsync()` naming was confusing:
- "value" sounds like a getter, not an action
- Doesn't clearly communicate "execute the pipeline"
- Not intuitive for new users

**Discussion**: Analyzed verb alternatives:
- `execute()` - Clear but generic and verbose
- `run()` - **WINNER** - Short (3 letters), natural ("run the pipeline"), matches ecosystem (npm run)
- `compute()` - Too academic/mathematical
- `flush()` - Implies clearing/emptying

**Decision**: Use `.run()` / `.runAsync()` because:
- ‚úÖ Clear intent: "run the pipeline"
- ‚úÖ Short and memorable
- ‚úÖ Matches mental model (npm run, scripts run)
- ‚úÖ Active voice, clear action
- ‚úÖ Industry standard for task execution

**Rationale for Keeping Sync/Async Separate**:
Initially considered forcing everything async to avoid `await ... runAsync()` redundancy, but decided against it because:
- ‚úÖ **Lower barrier to entry** - Beginners don't need async concepts for simple sync chains
- ‚úÖ **Progressive disclosure** - Users learn sync first, then async
- ‚úÖ **Performance transparency** - Clear which operations have overhead
- ‚úÖ **Principle of least surprise** - Sync code looks sync, async looks async
- ‚úÖ **Matches Node.js patterns** - Similar to `fs.readFileSync()` / `fs.promises.readFile()`

**Files Changed**:
- Modified: `src/Gluify.ts` - Renamed methods
- Modified: All 5 example files - Updated usage
- Modified: `package.json` - Version bump to 2.0.0

**Migration**:
```typescript
// Before (v1.0.0):
const result = pipeline.value();
const asyncResult = await pipeline.valueAsync();

// After (v2.0.0):
const result = pipeline.run();
const asyncResult = await pipeline.runAsync();
```

---

### 3. Added `pipeAsync()` Method for Promise Resolution

**Problem**: When initial function returns a Promise, the next pipe receives `Promise<T>` instead of `T`:
```typescript
await gluify(fetchUser, id)
  .pipe((user) => user.name)  // ‚ùå user is Promise<User>, not User!
  .runAsync();
```

**Initial Solutions Considered**:
1. **Make gluify always async-aware** (Option 1)
   - ‚ùå Forces all chains to be async
   - ‚ùå Breaking change for sync chains
   - ‚ùå Unnecessary overhead

2. **Make pipe always async-aware**
   - ‚ùå Even worse - every pipe becomes async
   - ‚ùå More overhead than Option 1

3. **User-controlled method** ‚úÖ
   - Two approaches debated: `awaitBefore()` vs `awaitPipe()`
   - **Decision: `awaitPipe()` initially** (later renamed to `pipeAsync()`)

**Reasoning**: 99% of the time, you await because you want to pipe the resolved value. One method is more ergonomic than two.

---

### 4. Renamed `awaitPipe()` ‚Üí `pipeAsync()` for Consistency

**Problem**: `awaitPipe()` didn't follow established naming patterns and was less discoverable.

**Analysis**:
- **Discoverability**: When users type "pipe" or "async" in autocomplete, `pipeAsync()` appears but `awaitPipe()` might not
- **Naming Pattern**:
  - JavaScript convention: `await` = keyword (prefix), `Async` = suffix for functions
  - Our API: `.run()` / `.runAsync()` uses Async suffix
  - Mixing them: `awaitPipe()` violates pattern consistency

**API Consistency Comparison**:

Before (inconsistent):
```typescript
.pipe()        // Sync pipe
.awaitPipe()   // Async pipe - uses "await" prefix ‚ùå
.run()         // Sync execution
.runAsync()    // Async execution - uses "Async" suffix ‚úÖ
```

After (consistent):
```typescript
.pipe()        // Sync pipe
.pipeAsync()   // Async pipe - uses "Async" suffix ‚úÖ
.run()         // Sync execution
.runAsync()    // Async execution - uses "Async" suffix ‚úÖ
```

**User Insight**: "await is only for prefix (await keyword) and async for suffix (function names)"

**Decision**: Rename to `pipeAsync()` because:
- ‚úÖ **Pattern consistency** - Matches `runAsync()` naming
- ‚úÖ **Discoverability** - Type "pipe" ‚Üí see both options
- ‚úÖ **JavaScript conventions** - Follows established async suffix pattern
- ‚úÖ **Semantic clarity** - "Async pipe" is clearer than "await-pipe"

**Files Changed**:
- Modified: `src/Gluify.ts` - Renamed method
- Renamed: `examples/test-async-awaitPipe.ts` ‚Üí `examples/test-async-pipeAsync.ts`
- Modified: `package.json` - Updated script reference

**Usage**:
```typescript
// Your use case - clean and intuitive:
await gluify(this.getFileInfo, id)
  .pipeAsync(fileInfo => fileInfo.path_collection.entries.slice(1))
  .pipe(entries => entries.map(e => e.name))
  .runAsync();
```

---

## Final API (v2.0.0)

### Perfect Symmetry Achieved üéØ

```typescript
class Gluify<T> {
  // Piping methods
  pipe<U>(fn)        // Sync pipe
  pipeAsync<U>(fn)   // Async pipe - awaits promises first

  // Execution methods
  run()              // Sync execution
  runAsync()         // Async execution
}
```

**Naming Pattern**: All async operations use `Async` suffix for consistency and discoverability.

---

## Design Principles Established

1. **Progressive Disclosure** - Simple concepts first (sync), advanced concepts later (async)
2. **Explicit Over Implicit** - Clear method names that show intent (`.run()` not `.value()`)
3. **Pattern Consistency** - Unified naming conventions across the API (`Async` suffix)
4. **Discoverability** - Method names match what users search for
5. **Industry Alignment** - Follow patterns from Node.js and popular libraries
6. **User-First Design** - Optimize for all skill levels, not just experts

---

## Breaking Changes Summary (v1.0.0 ‚Üí v2.0.0)

1. ‚ùå `.value()` ‚Üí ‚úÖ `.run()`
2. ‚ùå `.valueAsync()` ‚Üí ‚úÖ `.runAsync()`
3. ‚úÖ **NEW**: `.pipeAsync()` - Handle promises in chains

---

## Testing

All tests pass with new API:
- ‚úÖ Basic examples (sync chains)
- ‚úÖ Error handling
- ‚úÖ Array/Object/String utilities
- ‚úÖ Lazy evaluation
- ‚úÖ **Async with pipeAsync** (user's use case)

Example output:
```
Example 4: File path extraction (your use case)
Final result: folder1/folder2
Expected: folder1/folder2 ‚úÖ
```

---

## Key Insights from Design Discussion

### On Naming (`.run()` vs `.execute()` vs `.value()`)
- Users preferred `.run()` for its brevity and clarity
- "Run the pipeline" is natural language
- Matches ecosystem conventions (npm run, test runners)

### On Async Handling
- Forcing everything async would exclude beginners
- Explicit `await ... runAsync()` is acceptable "redundancy" - it's self-documenting
- Performance transparency matters (users can see sync vs async)

### On API Consistency
- Pattern consistency > feature parity with Promises
- `pipeAsync()` more discoverable than `.then()`
- Avoid overloading familiar terms (`.then()` is Promise territory)

---

## Documentation TODO

- [ ] Update README.md with v2.0.0 API
- [ ] Update CHANGELOG.md
- [ ] Add migration guide for v1 ‚Üí v2
- [ ] Document `pipeAsync()` use cases
- [ ] Update all code examples

---

## Future Considerations

### Potential Features (Not Implemented)
- `awaitBefore()` - If users need to await without immediate pipe (rare)
- Auto-detection of Promise returns - Rejected (too implicit, hurts type safety)

### Performance Notes
- Sync chains stay 100% synchronous (no Promise overhead)
- Async chains only use Promises when needed
- `pipeAsync()` only awaits when value is actually a Promise

---

## Files Modified Today

**Core Library**:
- `src/Gluify.ts` - Added `pipeAsync()`, renamed `value()`/`valueAsync()` to `run()`/`runAsync()`
- `index.js` - Created hand-written entry point
- `index.d.ts` - Created hand-written type definitions

**Configuration**:
- `package.json` - Version 2.0.0, updated main/types/exports, added index files
- `tsconfig.json` - Compile only source files

**Examples**:
- `examples/test-examples.ts` - Updated to use `.run()` / `.runAsync()`
- `examples/test-error-handling.ts` - Updated to use `.run()` / `.runAsync()`
- `examples/test-utilities.ts` - Updated to use `.run()` / `.runAsync()`
- `examples/test-lazy-evaluation.ts` - Updated to use `.run()` / `.runAsync()`
- `examples/test-async-awaitPipe.ts` ‚Üí `examples/test-async-pipeAsync.ts` - Renamed and updated to use `.pipeAsync()` / `.runAsync()`

---

## Lessons Learned

1. **User feedback drives great API design** - The insights about naming patterns came from user discussion
2. **Industry patterns matter** - Following Node.js conventions reduces cognitive load
3. **Consistency is worth breaking changes** - v2.0.0 is a better foundation for future growth
4. **Discoverability is underrated** - Method names should match what users search for
5. **Don't force complexity** - Keeping sync simple is more important than API unification

---

## Migration Path for Users

For users upgrading from v1.0.0:

```typescript
// Step 1: Rename execution methods
.value()      ‚Üí .run()
.valueAsync() ‚Üí .runAsync()

// Step 2: Use pipeAsync() for promise resolution
// Before (v1.0.0) - type error:
await gluify(fetchUser, id)
  .pipe(user => user.name)  // ‚ùå user is Promise<User>

// After (v2.0.0) - works correctly:
await gluify(fetchUser, id)
  .pipeAsync(user => user.name)  // ‚úÖ user is User
  .runAsync()
```

Simple find-replace migration, clear upgrade path.

---

## Version 2.0.0 Ready for Release ‚úÖ

- ‚úÖ All tests passing
- ‚úÖ Breaking changes documented
- ‚úÖ Examples updated
- ‚úÖ Build successful
- ‚úÖ Clear migration path
- üéØ Better API for long-term growth
